<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>State Management - TuPhung Project Documentation</title>
  <link rel="stylesheet" href="../../css/style.css">
  <!-- Mermaid for flowcharts -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.0/dist/mermaid.min.js"></script>
  <!-- Prism for code highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
</head>
<body>
  <button class="menu-toggle">â˜°</button>
  
  <aside class="sidebar">
    <div class="sidebar-header">
      <h1>TuPhung Project</h1>
    </div>
    
    <nav class="sidebar-nav">
      <div class="sidebar-section">
        <div class="sidebar-section-title">Overview</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../../index.html" class="sidebar-subnav-link">Introduction</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../architecture.html" class="sidebar-subnav-link">Architecture</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../tech-stack.html" class="sidebar-subnav-link">Tech Stack</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Frontend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="auth.html" class="sidebar-subnav-link">Authentication</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="chat.html" class="sidebar-subnav-link">Chat System</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="kanban.html" class="sidebar-subnav-link">Kanban Board</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="calendar.html" class="sidebar-subnav-link">Calendar</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="ai-assistants.html" class="sidebar-subnav-link">AI Assistants</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="language-ai.html" class="sidebar-subnav-link">Language AI</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="state-management.html" class="sidebar-subnav-link active">State Management</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Backend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../backend/structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/auth.html" class="sidebar-subnav-link">Authentication & Security</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/database.html" class="sidebar-subnav-link">Database Design</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/api.html" class="sidebar-subnav-link">API Endpoints</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/websockets.html" class="sidebar-subnav-link">WebSockets</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/speech-processing.html" class="sidebar-subnav-link">Speech Processing</a>
          </li>
        </ul>
      </div>
    </nav>
  </aside>
  
  <main class="main-content">
    <header class="content-header">
      <h1>State Management</h1>
      <p>Comprehensive documentation of the state management approach in the TuPhung Project.</p>
    </header>
    
    <section>
      <h2>Overview</h2>
      <p>
        The TuPhung Project implements a robust state management system using Redux with Redux Toolkit. 
        This approach provides a centralized store for all application state, making it easier to manage 
        complex state interactions, implement features like undo/redo, and ensure predictable state updates.
      </p>
      
      <div class="component-card">
        <h3>Key Features</h3>
        <ul>
          <li><strong>Centralized State</strong> - Single source of truth for application data</li>
          <li><strong>Predictable Updates</strong> - State changes follow a unidirectional data flow</li>
          <li><strong>Immutable State</strong> - State is never directly modified, ensuring traceability</li>
          <li><strong>Modular Architecture</strong> - State is organized into feature-specific slices</li>
          <li><strong>Type Safety</strong> - TypeScript integration ensures type-safe state access</li>
          <li><strong>Middleware Support</strong> - Extensible with middleware for async operations, logging, etc.</li>
          <li><strong>DevTools Integration</strong> - Powerful debugging with Redux DevTools</li>
          <li><strong>Optimized Performance</strong> - Selective re-rendering with React-Redux hooks</li>
        </ul>
      </div>
      
      <h2>Architecture</h2>
      
      <div class="diagram-container">
        <div class="diagram-title">State Management Architecture</div>
        <div class="mermaid">
          graph TD
            Component[React Component] --> Hooks[React-Redux Hooks]
            Hooks --> Dispatch[Dispatch Action]
            Dispatch --> Action[Action Creator]
            Action --> Thunk{Is Thunk?}
            
            Thunk -->|Yes| AsyncLogic[Async Logic]
            AsyncLogic --> API[API Service]
            API --> AsyncLogic
            AsyncLogic --> Action2[Action Creator]
            
            Thunk -->|No| Reducer[Reducer]
            Action2 --> Reducer
            
            Reducer --> Store[Redux Store]
            Store --> Selector[Selector]
            Selector --> Hooks
            
            subgraph "Component Layer"
              Component
              Hooks
            end
            
            subgraph "Action Layer"
              Dispatch
              Action
              Thunk
              AsyncLogic
              Action2
            end
            
            subgraph "State Layer"
              Reducer
              Store
              Selector
            end
            
            subgraph "External Services"
              API
            end
        </div>
      </div>
      
      <h2>Store Configuration</h2>
      
      <p>
        The Redux store is configured using Redux Toolkit's configureStore function, which provides 
        sensible defaults and integrates popular middleware like redux-thunk for handling async logic.
      </p>
      
      <div class="component-card">
        <h3>Store Setup</h3>
        <pre><code class="language-typescript">// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';
import rootReducer from './rootReducer';
import { apiMiddleware } from './middleware/apiMiddleware';
import { loggerMiddleware } from './middleware/loggerMiddleware';

export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => 
    getDefaultMiddleware()
      .concat(apiMiddleware)
      .concat(process.env.NODE_ENV === 'development' ? loggerMiddleware : []),
  devTools: process.env.NODE_ENV !== 'production',
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType&lt;typeof store.getState&gt;;
export type AppDispatch = typeof store.dispatch;

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch&lt;AppDispatch&gt;();
export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;</code></pre>
        
        <h3>Root Reducer</h3>
        <pre><code class="language-typescript">// src/store/rootReducer.ts
import { combineReducers } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import userReducer from './slices/userSlice';
import chatReducer from './slices/chatSlice';
import kanbanReducer from './slices/kanbanSlice';
import calendarReducer from './slices/calendarSlice';
import assistantAIReducer from './slices/assistantAISlice';
import languageAIReducer from './slices/languageAISlice';
import uiReducer from './slices/uiSlice';

const rootReducer = combineReducers({
  auth: authReducer,
  user: userReducer,
  chat: chatReducer,
  kanban: kanbanReducer,
  calendar: calendarReducer,
  assistantAI: assistantAIReducer,
  languageAI: languageAIReducer,
  ui: uiReducer,
});

export default rootReducer;</code></pre>
      </div>
      
      <h2>Feature Slices</h2>
      
      <p>
        The application state is organized into feature-specific slices using Redux Toolkit's createSlice function. 
        Each slice encapsulates the reducer logic and action creators for a specific feature domain.
      </p>
      
      <div class="component-card">
        <h3>Authentication Slice</h3>
        <pre><code class="language-typescript">// src/store/slices/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { loginUser, registerUser, logoutUser, refreshToken } from '../../services/authService';
import { User, LoginCredentials, RegisterData } from '../../types/auth';

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  user: null,
  token: localStorage.getItem('token'),
  isAuthenticated: !!localStorage.getItem('token'),
  loading: false,
  error: null,
};

// Async thunks
export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginCredentials, { rejectWithValue }) => {
    try {
      const response = await loginUser(credentials);
      localStorage.setItem('token', response.token);
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Login failed');
    }
  }
);

export const register = createAsyncThunk(
  'auth/register',
  async (userData: RegisterData, { rejectWithValue }) => {
    try {
      const response = await registerUser(userData);
      localStorage.setItem('token', response.token);
      return response;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Registration failed');
    }
  }
);

export const logout = createAsyncThunk(
  'auth/logout',
  async (_, { rejectWithValue }) => {
    try {
      await logoutUser();
      localStorage.removeItem('token');
      return null;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Logout failed');
    }
  }
);

export const refresh = createAsyncThunk(
  'auth/refresh',
  async (_, { rejectWithValue }) => {
    try {
      const response = await refreshToken();
      localStorage.setItem('token', response.token);
      return response;
    } catch (error) {
      localStorage.removeItem('token');
      return rejectWithValue(error.response?.data?.message || 'Token refresh failed');
    }
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setCredentials: (state, action: PayloadAction&lt;{ user: User; token: string }&gt;) => {
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
      localStorage.setItem('token', action.payload.token);
    },
    clearCredentials: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      localStorage.removeItem('token');
    },
    setError: (state, action: PayloadAction&lt;string | null&gt;) => {
      state.error = action.payload;
    },
  },
  extraReducers: (builder) => {
    // Login
    builder.addCase(login.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(login.fulfilled, (state, action) => {
      state.loading = false;
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
    });
    builder.addCase(login.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Register
    builder.addCase(register.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(register.fulfilled, (state, action) => {
      state.loading = false;
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
    });
    builder.addCase(register.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Logout
    builder.addCase(logout.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(logout.fulfilled, (state) => {
      state.loading = false;
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
    });
    builder.addCase(logout.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Refresh token
    builder.addCase(refresh.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(refresh.fulfilled, (state, action) => {
      state.loading = false;
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
    });
    builder.addCase(refresh.rejected, (state) => {
      state.loading = false;
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
    });
  },
});

export const { setCredentials, clearCredentials, setError } = authSlice.actions;

export default authSlice.reducer;</code></pre>
        
        <h3>Kanban Slice</h3>
        <pre><code class="language-typescript">// src/store/slices/kanbanSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { 
  fetchBoards, 
  fetchBoard, 
  createBoard, 
  updateBoard, 
  deleteBoard,
  createList,
  updateList,
  deleteList,
  createCard,
  updateCard,
  deleteCard,
  moveCard
} from '../../services/kanbanService';
import { Board, List, Card, CardMove } from '../../types/kanban';

interface KanbanState {
  boards: Board[];
  currentBoard: Board | null;
  loading: boolean;
  error: string | null;
}

const initialState: KanbanState = {
  boards: [],
  currentBoard: null,
  loading: false,
  error: null,
};

// Async thunks
export const fetchAllBoards = createAsyncThunk(
  'kanban/fetchAllBoards',
  async (_, { rejectWithValue }) => {
    try {
      return await fetchBoards();
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch boards');
    }
  }
);

export const fetchBoardById = createAsyncThunk(
  'kanban/fetchBoardById',
  async (boardId: string, { rejectWithValue }) => {
    try {
      return await fetchBoard(boardId);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch board');
    }
  }
);

export const addBoard = createAsyncThunk(
  'kanban/addBoard',
  async (boardData: Omit&lt;Board, 'id' | 'lists'&gt;, { rejectWithValue }) => {
    try {
      return await createBoard(boardData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to create board');
    }
  }
);

export const editBoard = createAsyncThunk(
  'kanban/editBoard',
  async ({ boardId, boardData }: { boardId: string; boardData: Partial&lt;Board&gt; }, { rejectWithValue }) => {
    try {
      return await updateBoard(boardId, boardData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to update board');
    }
  }
);

export const removeBoard = createAsyncThunk(
  'kanban/removeBoard',
  async (boardId: string, { rejectWithValue }) => {
    try {
      await deleteBoard(boardId);
      return boardId;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to delete board');
    }
  }
);

export const addList = createAsyncThunk(
  'kanban/addList',
  async ({ boardId, listData }: { boardId: string; listData: Omit&lt;List, 'id' | 'cards'&gt; }, { rejectWithValue }) => {
    try {
      return await createList(boardId, listData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to create list');
    }
  }
);

export const editList = createAsyncThunk(
  'kanban/editList',
  async ({ listId, listData }: { listId: string; listData: Partial&lt;List&gt; }, { rejectWithValue }) => {
    try {
      return await updateList(listId, listData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to update list');
    }
  }
);

export const removeList = createAsyncThunk(
  'kanban/removeList',
  async ({ boardId, listId }: { boardId: string; listId: string }, { rejectWithValue }) => {
    try {
      await deleteList(boardId, listId);
      return { boardId, listId };
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to delete list');
    }
  }
);

export const addCard = createAsyncThunk(
  'kanban/addCard',
  async ({ listId, cardData }: { listId: string; cardData: Omit&lt;Card, 'id'&gt; }, { rejectWithValue }) => {
    try {
      return await createCard(listId, cardData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to create card');
    }
  }
);

export const editCard = createAsyncThunk(
  'kanban/editCard',
  async ({ cardId, cardData }: { cardId: string; cardData: Partial&lt;Card&gt; }, { rejectWithValue }) => {
    try {
      return await updateCard(cardId, cardData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to update card');
    }
  }
);

export const removeCard = createAsyncThunk(
  'kanban/removeCard',
  async ({ listId, cardId }: { listId: string; cardId: string }, { rejectWithValue }) => {
    try {
      await deleteCard(listId, cardId);
      return { listId, cardId };
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to delete card');
    }
  }
);

export const moveCardItem = createAsyncThunk(
  'kanban/moveCard',
  async (moveData: CardMove, { rejectWithValue }) => {
    try {
      return await moveCard(moveData);
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Failed to move card');
    }
  }
);

const kanbanSlice = createSlice({
  name: 'kanban',
  initialState,
  reducers: {
    setCurrentBoard: (state, action: PayloadAction&lt;Board | null&gt;) => {
      state.currentBoard = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Fetch all boards
    builder.addCase(fetchAllBoards.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchAllBoards.fulfilled, (state, action) => {
      state.loading = false;
      state.boards = action.payload;
    });
    builder.addCase(fetchAllBoards.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Fetch board by ID
    builder.addCase(fetchBoardById.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchBoardById.fulfilled, (state, action) => {
      state.loading = false;
      state.currentBoard = action.payload;
    });
    builder.addCase(fetchBoardById.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Add board
    builder.addCase(addBoard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(addBoard.fulfilled, (state, action) => {
      state.loading = false;
      state.boards.push(action.payload);
    });
    builder.addCase(addBoard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Edit board
    builder.addCase(editBoard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(editBoard.fulfilled, (state, action) => {
      state.loading = false;
      const index = state.boards.findIndex(board => board.id === action.payload.id);
      if (index !== -1) {
        state.boards[index] = action.payload;
      }
      if (state.currentBoard?.id === action.payload.id) {
        state.currentBoard = action.payload;
      }
    });
    builder.addCase(editBoard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Remove board
    builder.addCase(removeBoard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(removeBoard.fulfilled, (state, action) => {
      state.loading = false;
      state.boards = state.boards.filter(board => board.id !== action.payload);
      if (state.currentBoard?.id === action.payload) {
        state.currentBoard = null;
      }
    });
    builder.addCase(removeBoard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Add list
    builder.addCase(addList.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(addList.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.id === action.payload.boardId) {
        if (!state.currentBoard.lists) {
          state.currentBoard.lists = [];
        }
        state.currentBoard.lists.push(action.payload);
      }
    });
    builder.addCase(addList.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Edit list
    builder.addCase(editList.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(editList.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.lists) {
        const listIndex = state.currentBoard.lists.findIndex(list => list.id === action.payload.id);
        if (listIndex !== -1) {
          state.currentBoard.lists[listIndex] = {
            ...state.currentBoard.lists[listIndex],
            ...action.payload,
          };
        }
      }
    });
    builder.addCase(editList.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Remove list
    builder.addCase(removeList.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(removeList.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.id === action.payload.boardId) {
        state.currentBoard.lists = state.currentBoard.lists.filter(
          list => list.id !== action.payload.listId
        );
      }
    });
    builder.addCase(removeList.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Add card
    builder.addCase(addCard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(addCard.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.lists) {
        const listIndex = state.currentBoard.lists.findIndex(list => list.id === action.payload.listId);
        if (listIndex !== -1) {
          if (!state.currentBoard.lists[listIndex].cards) {
            state.currentBoard.lists[listIndex].cards = [];
          }
          state.currentBoard.lists[listIndex].cards.push(action.payload);
        }
      }
    });
    builder.addCase(addCard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Edit card
    builder.addCase(editCard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(editCard.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.lists) {
        const listIndex = state.currentBoard.lists.findIndex(list => 
          list.cards && list.cards.some(card => card.id === action.payload.id)
        );
        if (listIndex !== -1 && state.currentBoard.lists[listIndex].cards) {
          const cardIndex = state.currentBoard.lists[listIndex].cards.findIndex(
            card => card.id === action.payload.id
          );
          if (cardIndex !== -1) {
            state.currentBoard.lists[listIndex].cards[cardIndex] = {
              ...state.currentBoard.lists[listIndex].cards[cardIndex],
              ...action.payload,
            };
          }
        }
      }
    });
    builder.addCase(editCard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Remove card
    builder.addCase(removeCard.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(removeCard.fulfilled, (state, action) => {
      state.loading = false;
      if (state.currentBoard && state.currentBoard.lists) {
        const listIndex = state.currentBoard.lists.findIndex(list => list.id === action.payload.listId);
        if (listIndex !== -1 && state.currentBoard.lists[listIndex].cards) {
          state.currentBoard.lists[listIndex].cards = state.currentBoard.lists[listIndex].cards.filter(
            card => card.id !== action.payload.cardId
          );
        }
      }
    });
    builder.addCase(removeCard.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // Move card
    builder.addCase(moveCardItem.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(moveCardItem.fulfilled, (state, action) => {
      state.loading = false;
      // The backend returns the updated board structure after the move
      if (action.payload.id === state.currentBoard?.id) {
        state.currentBoard = action.payload;
      }
    });
    builder.addCase(moveCardItem.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
  },
});

export const { setCurrentBoard, clearError } = kanbanSlice.actions;

export default kanbanSlice.reducer;</code></pre>
      </div>
      
      <h2>Middleware</h2>
      
      <p>
        The application uses custom middleware to extend Redux's capabilities, such as handling API requests, 
        logging, and implementing features like undo/redo.
      </p>
      
      <div class="component-card">
        <h3>API Middleware</h3>
        <pre><code class="language-typescript">// src/store/middleware/apiMiddleware.ts
import { Middleware } from 'redux';
import axios from 'axios';
import { RootState } from '../index';
import { refresh, clearCredentials } from '../slices/authSlice';

export const apiMiddleware: Middleware&lt;{}, RootState&gt; = ({ dispatch, getState }) => next => async action => {
  // Pass non-API actions to the next middleware
  if (!action.meta?.isApiRequest) {
    return next(action);
  }
  
  // Get the current token from state
  const { auth } = getState();
  const token = auth.token;
  
  // Set up request config
  const { url, method, data, headers = {} } = action.payload;
  const requestConfig = {
    url,
    method,
    data,
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
      ...headers,
    },
  };
  
  // Dispatch the pending action
  dispatch({ type: `${action.type}_PENDING` });
  
  try {
    // Make the API request
    const response = await axios(requestConfig);
    
    // Dispatch the success action
    dispatch({
      type: `${action.type}_FULFILLED`,
      payload: response.data,
    });
    
    return response.data;
  } catch (error) {
    // Handle token expiration
    if (error.response?.status === 401 && token) {
      try {
        // Try to refresh the token
        await dispatch(refresh());
        
        // Retry the original request with the new token
        const newToken = getState().auth.token;
        if (newToken) {
          const retryConfig = {
            ...requestConfig,
            headers: {
              ...requestConfig.headers,
              Authorization: `Bearer ${newToken}`,
            },
          };
          
          const retryResponse = await axios(retryConfig);
          
          dispatch({
            type: `${action.type}_FULFILLED`,
            payload: retryResponse.data,
          });
          
          return retryResponse.data;
        }
      } catch (refreshError) {
        // If token refresh fails, log the user out
        dispatch(clearCredentials());
      }
    }
    
    // Dispatch the error action
    dispatch({
      type: `${action.type}_REJECTED`,
      payload: error.response?.data || { message: error.message },
      error: true,
    });
    
    throw error;
  }
};</code></pre>
        
        <h3>Logger Middleware</h3>
        <pre><code class="language-typescript">// src/store/middleware/loggerMiddleware.ts
import { Middleware } from 'redux';
import { RootState } from '../index';

export const loggerMiddleware: Middleware&lt;{}, RootState&gt; = store => next => action => {
  if (process.env.NODE_ENV !== 'production') {
    console.group(`Action: ${action.type}`);
    console.log('Previous state:', store.getState());
    console.log('Action:', action);
    const result = next(action);
    console.log('Next state:', store.getState());
    console.groupEnd();
    return result;
  }
  
  return next(action);
};</code></pre>
      </div>
      
      <h2>Selectors</h2>
      
      <p>
        Selectors are used to efficiently extract and derive data from the Redux store. The application 
        uses memoized selectors with Reselect to optimize performance by avoiding unnecessary recalculations.
      </p>
      
      <div class="component-card">
        <h3>Memoized Selectors</h3>
        <pre><code class="language-typescript">// src/store/selectors/kanbanSelectors.ts
import { createSelector } from '@reduxjs/toolkit';
import { RootState } from '../index';
import { Board, List, Card } from '../../types/kanban';

// Basic selectors
export const selectKanbanState = (state: RootState) => state.kanban;
export const selectBoards = (state: RootState) => state.kanban.boards;
export const selectCurrentBoard = (state: RootState) => state.kanban.currentBoard;
export const selectKanbanLoading = (state: RootState) => state.kanban.loading;
export const selectKanbanError = (state: RootState) => state.kanban.error;

// Memoized selectors
export const selectBoardById = createSelector(
  [selectBoards, (_, boardId: string) => boardId],
  (boards, boardId) => boards.find(board => board.id === boardId) || null
);

export const selectListsForCurrentBoard = createSelector(
  [selectCurrentBoard],
  (currentBoard) => currentBoard?.lists || []
);

export const selectListById = createSelector(
  [selectListsForCurrentBoard, (_, listId: string) => listId],
  (lists, listId) => lists.find(list => list.id === listId) || null
);

export const selectCardsForList = createSelector(
  [selectListById],
  (list) => list?.cards || []
);

export const selectCardById = createSelector(
  [
    selectListsForCurrentBoard,
    (_, cardId: string) => cardId
  ],
  (lists, cardId) => {
    for (const list of lists) {
      if (list.cards) {
        const card = list.cards.find(card => card.id === cardId);
        if (card) return card;
      }
    }
    return null;
  }
);

export const selectCardsByLabel = createSelector(
  [selectListsForCurrentBoard, (_, label: string) => label],
  (lists, label) => {
    const cards: Card[] = [];
    lists.forEach(list => {
      if (list.cards) {
        list.cards.forEach(card => {
          if (card.labels && card.labels.includes(label)) {
            cards.push(card);
          }
        });
      }
    });
    return cards;
  }
);

export const selectCardsByAssignee = createSelector(
  [selectListsForCurrentBoard, (_, userId: string) => userId],
  (lists, userId) => {
    const cards: Card[] = [];
    lists.forEach(list => {
      if (list.cards) {
        list.cards.forEach(card => {
          if (card.assignees && card.assignees.includes(userId)) {
            cards.push(card);
          }
        });
      }
    });
    return cards;
  }
);

export const selectBoardStatistics = createSelector(
  [selectCurrentBoard],
  (board) => {
    if (!board) return null;
    
    const lists = board.lists || [];
    const totalLists = lists.length;
    let totalCards = 0;
    let completedCards = 0;
    
    lists.forEach(list => {
      const cards = list.cards || [];
      totalCards += cards.length;
      
      // Assuming cards with a 'completed' status are considered done
      completedCards += cards.filter(card => card.status === 'completed').length;
    });
    
    return {
      totalLists,
      totalCards,
      completedCards,
      completionRate: totalCards > 0 ? (completedCards / totalCards) * 100 : 0,
    };
  }
);</code></pre>
      </div>
      
      <h2>Hooks</h2>
      
      <p>
        Custom hooks are used to encapsulate Redux logic and provide a clean, reusable interface for components 
        to interact with the store.
      </p>
      
      <div class="component-card">
        <h3>Authentication Hooks</h3>
        <pre><code class="language-typescript">// src/hooks/useAuth.ts
import { useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../store';
import { login, register, logout, refresh } from '../store/slices/authSlice';
import { LoginCredentials, RegisterData } from '../types/auth';

export const useAuth = () => {
  const dispatch = useAppDispatch();
  const { user, token, isAuthenticated, loading, error } = useAppSelector(state => state.auth);
  
  const loginUser = useCallback(
    (credentials: LoginCredentials) => dispatch(login(credentials)),
    [dispatch]
  );
  
  const registerUser = useCallback(
    (userData: RegisterData) => dispatch(register(userData)),
    [dispatch]
  );
  
  const logoutUser = useCallback(
    () => dispatch(logout()),
    [dispatch]
  );
  
  const refreshToken = useCallback(
    () => dispatch(refresh()),
    [dispatch]
  );
  
  return {
    user,
    token,
    isAuthenticated,
    loading,
    error,
    loginUser,
    registerUser,
    logoutUser,
    refreshToken,
  };
};</code></pre>
        
        <h3>Kanban Hooks</h3>
        <pre><code class="language-typescript">// src/hooks/useKanban.ts
import { useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../store';
import {
  fetchAllBoards,
  fetchBoardById,
  addBoard,
  editBoard,
  removeBoard,
  addList,
  editList,
  removeList,
  addCard,
  editCard,
  removeCard,
  moveCardItem,
  setCurrentBoard,
} from '../store/slices/kanbanSlice';
import {
  selectBoards,
  selectCurrentBoard,
  selectKanbanLoading,
  selectKanbanError,
  selectBoardById,
  selectListsForCurrentBoard,
  selectListById,
  selectCardsForList,
  selectCardById,
  selectBoardStatistics,
} from '../store/selectors/kanbanSelectors';
import { Board, List, Card, CardMove } from '../types/kanban';

export const useKanban = () => {
  const dispatch = useAppDispatch();
  
  // Basic state selectors
  const boards = useAppSelector(selectBoards);
  const currentBoard = useAppSelector(selectCurrentBoard);
  const loading = useAppSelector(selectKanbanLoading);
  const error = useAppSelector(selectKanbanError);
  
  // Board operations
  const loadBoards = useCallback(
    () => dispatch(fetchAllBoards()),
    [dispatch]
  );
  
  const loadBoard = useCallback(
    (boardId: string) => dispatch(fetchBoardById(boardId)),
    [dispatch]
  );
  
  const createNewBoard = useCallback(
    (boardData: Omit&lt;Board, 'id' | 'lists'&gt;) => dispatch(addBoard(boardData)),
    [dispatch]
  );
  
  const updateBoard = useCallback(
    (boardId: string, boardData: Partial&lt;Board&gt;) => 
      dispatch(editBoard({ boardId, boardData })),
    [dispatch]
  );
  
  const deleteBoard = useCallback(
    (boardId: string) => dispatch(removeBoard(boardId)),
    [dispatch]
  );
  
  const selectBoard = useCallback(
    (board: Board | null) => dispatch(setCurrentBoard(board)),
    [dispatch]
  );
  
  // List operations
  const createNewList = useCallback(
    (boardId: string, listData: Omit&lt;List, 'id' | 'cards'&gt;) => 
      dispatch(addList({ boardId, listData })),
    [dispatch]
  );
  
  const updateList = useCallback(
    (listId: string, listData: Partial&lt;List&gt;) => 
      dispatch(editList({ listId, listData })),
    [dispatch]
  );
  
  const deleteList = useCallback(
    (boardId: string, listId: string) => 
      dispatch(removeList({ boardId, listId })),
    [dispatch]
  );
  
  // Card operations
  const createNewCard = useCallback(
    (listId: string, cardData: Omit&lt;Card, 'id'&gt;) => 
      dispatch(addCard({ listId, cardData })),
    [dispatch]
  );
  
  const updateCard = useCallback(
    (cardId: string, cardData: Partial&lt;Card&gt;) => 
      dispatch(editCard({ cardId, cardData })),
    [dispatch]
  );
  
  const deleteCard = useCallback(
    (listId: string, cardId: string) => 
      dispatch(removeCard({ listId, cardId })),
    [dispatch]
  );
  
  const moveCard = useCallback(
    (moveData: CardMove) => dispatch(moveCardItem(moveData)),
    [dispatch]
  );
  
  // Selector functions
  const getBoardById = useCallback(
    (boardId: string) => selectBoardById({ kanban: { boards } }, boardId),
    [boards]
  );
  
  const getListsForCurrentBoard = useCallback(
    () => selectListsForCurrentBoard({ kanban: { currentBoard } }),
    [currentBoard]
  );
  
  const getListById = useCallback(
    (listId: string) => selectListById({ kanban: { currentBoard } }, listId),
    [currentBoard]
  );
  
  const getCardsForList = useCallback(
    (listId: string) => {
      const list = getListById(listId);
      return selectCardsForList({ kanban: { currentBoard } }, list);
    },
    [currentBoard, getListById]
  );
  
  const getCardById = useCallback(
    (cardId: string) => selectCardById({ kanban: { currentBoard } }, cardId),
    [currentBoard]
  );
  
  const getBoardStatistics = useCallback(
    () => selectBoardStatistics({ kanban: { currentBoard } }),
    [currentBoard]
  );
  
  return {
    // State
    boards,
    currentBoard,
    loading,
    error,
    
    // Board operations
    loadBoards,
    loadBoard,
    createNewBoard,
    updateBoard,
    deleteBoard,
    selectBoard,
    
    // List operations
    createNewList,
    updateList,
    deleteList,
    
    // Card operations
    createNewCard,
    updateCard,
    deleteCard,
    moveCard,
    
    // Selectors
    getBoardById,
    getListsForCurrentBoard,
    getListById,
    getCardsForList,
    getCardById,
    getBoardStatistics,
  };
};</code></pre>
      </div>
      
      <h2>Performance Optimization</h2>
      
      <p>
        The state management system includes several optimizations to ensure good performance even with 
        complex state and frequent updates.
      </p>
      
      <div class="component-card">
        <h3>Key Optimization Techniques</h3>
        <ul>
          <li><strong>Memoized Selectors</strong> - Using Reselect to avoid unnecessary recalculations</li>
          <li><strong>Normalized State</strong> - Organizing data in a normalized structure to minimize duplication</li>
          <li><strong>Selective Updates</strong> - Using React.memo and useCallback to prevent unnecessary re-renders</li>
          <li><strong>Batched Updates</strong> - Grouping multiple state changes to reduce render cycles</li>
          <li><strong>Lazy Loading</strong> - Loading state only when needed to reduce initial load time</li>
          <li><strong>Pagination</strong> - Loading large datasets in chunks to improve performance</li>
        </ul>
        
        <h3>Example: Normalized State Structure</h3>
        <pre><code class="language-typescript">// Example of normalized state structure
interface NormalizedState {
  entities: {
    users: {
      [id: string]: User;
    };
    boards: {
      [id: string]: Board;
    };
    lists: {
      [id: string]: List;
    };
    cards: {
      [id: string]: Card;
    };
  };
  ids: {
    users: string[];
    boards: string[];
    lists: string[];
    cards: string[];
  };
  relations: {
    boardLists: {
      [boardId: string]: string[]; // List IDs
    };
    listCards: {
      [listId: string]: string[]; // Card IDs
    };
    userBoards: {
      [userId: string]: string[]; // Board IDs
    };
  };
}</code></pre>
      </div>
      
      <h2>Testing</h2>
      
      <p>
        The state management system is thoroughly tested to ensure reliability and correctness.
      </p>
      
      <div class="component-card">
        <h3>Testing Approach</h3>
        <ul>
          <li><strong>Unit Tests</strong> - Testing individual reducers, selectors, and action creators</li>
          <li><strong>Integration Tests</strong> - Testing the interaction between different parts of the state</li>
          <li><strong>Mock Store Tests</strong> - Testing components with a mocked Redux store</li>
          <li><strong>Snapshot Tests</strong> - Ensuring state changes match expected patterns</li>
        </ul>
        
        <h3>Example: Reducer Test</h3>
        <pre><code class="language-typescript">// src/store/slices/__tests__/authSlice.test.ts
import authReducer, { 
  setCredentials, 
  clearCredentials, 
  setError 
} from '../authSlice';
import { User } from '../../../types/auth';

describe('Auth Reducer', () => {
  const initialState = {
    user: null,
    token: null,
    isAuthenticated: false,
    loading: false,
    error: null,
  };
  
  const mockUser: User = {
    id: '1',
    username: 'testuser',
    email: 'test@example.com',
    roles: ['user'],
  };
  
  const mockToken = 'mock-jwt-token';
  
  test('should return the initial state', () => {
    expect(authReducer(undefined, { type: '' })).toEqual(initialState);
  });
  
  test('should handle setCredentials', () => {
    const action = setCredentials({ user: mockUser, token: mockToken });
    const state = authReducer(initialState, action);
    
    expect(state).toEqual({
      ...initialState,
      user: mockUser,
      token: mockToken,
      isAuthenticated: true,
    });
  });
  
  test('should handle clearCredentials', () => {
    const startState = {
      ...initialState,
      user: mockUser,
      token: mockToken,
      isAuthenticated: true,
    };
    
    const action = clearCredentials();
    const state = authReducer(startState, action);
    
    expect(state).toEqual(initialState);
  });
  
  test('should handle setError', () => {
    const errorMessage = 'Authentication failed';
    const action = setError(errorMessage);
    const state = authReducer(initialState, action);
    
    expect(state).toEqual({
      ...initialState,
      error: errorMessage,
    });
  });
});</code></pre>
        
        <h3>Example: Selector Test</h3>
        <pre><code class="language-typescript">// src/store/selectors/__tests__/kanbanSelectors.test.ts
import {
  selectBoardById,
  selectListsForCurrentBoard,
  selectCardById,
  selectBoardStatistics,
} from '../kanbanSelectors';
import { RootState } from '../../index';

describe('Kanban Selectors', () => {
  const mockBoard = {
    id: 'board1',
    name: 'Test Board',
    description: 'Test Description',
    lists: [
      {
        id: 'list1',
        name: 'To Do',
        cards: [
          {
            id: 'card1',
            title: 'Task 1',
            description: 'Description 1',
            status: 'pending',
          },
          {
            id: 'card2',
            title: 'Task 2',
            description: 'Description 2',
            status: 'completed',
          },
        ],
      },
      {
        id: 'list2',
        name: 'In Progress',
        cards: [
          {
            id: 'card3',
            title: 'Task 3',
            description: 'Description 3',
            status: 'pending',
          },
        ],
      },
    ],
  };
  
  const mockState = {
    kanban: {
      boards: [mockBoard],
      currentBoard: mockBoard,
      loading: false,
      error: null,
    },
  } as RootState;
  
  test('selectBoardById should return the correct board', () => {
    const result = selectBoardById(mockState, 'board1');
    expect(result).toEqual(mockBoard);
  });
  
  test('selectBoardById should return null for non-existent board', () => {
    const result = selectBoardById(mockState, 'nonexistent');
    expect(result).toBeNull();
  });
  
  test('selectListsForCurrentBoard should return all lists for the current board', () => {
    const result = selectListsForCurrentBoard(mockState);
    expect(result).toEqual(mockBoard.lists);
  });
  
  test('selectCardById should return the correct card', () => {
    const result = selectCardById(mockState, 'card2');
    expect(result).toEqual(mockBoard.lists[0].cards[1]);
  });
  
  test('selectBoardStatistics should calculate correct statistics', () => {
    const result = selectBoardStatistics(mockState);
    expect(result).toEqual({
      totalLists: 2,
      totalCards: 3,
      completedCards: 1,
      completionRate: (1 / 3) * 100,
    });
  });
});</code></pre>
      </div>
      
      <h2>Best Practices</h2>
      
      <p>
        The state management system follows several best practices to ensure maintainability, scalability, and performance.
      </p>
      
      <div class="component-card">
        <h3>Key Best Practices</h3>
        <ul>
          <li><strong>Single Source of Truth</strong> - All application state is stored in a single Redux store</li>
          <li><strong>Immutable Updates</strong> - State is never directly modified, ensuring predictable behavior</li>
          <li><strong>Action Type Constants</strong> - Using descriptive action types to improve debugging</li>
          <li><strong>Normalized State Shape</strong> - Organizing related data in a normalized structure</li>
          <li><strong>Selector Pattern</strong> - Using selectors to access and derive state</li>
          <li><strong>Thunk Pattern</strong> - Using thunks for async logic and side effects</li>
          <li><strong>Error Handling</strong> - Consistent approach to handling and displaying errors</li>
          <li><strong>Type Safety</strong> - Using TypeScript to ensure type safety throughout the state management system</li>
        </ul>
      </div>
    </section>
  </main>
  
  <script src="../../assets/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script>
    // Initialize syntax highlighting and mermaid diagrams
    document.addEventListener('DOMContentLoaded', (event) => {
      Prism.highlightAll();
      mermaid.initialize({ startOnLoad: true });
    });
  </script>
</body>
</html>