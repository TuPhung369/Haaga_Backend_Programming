<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calendar - TuPhung Project Documentation</title>
  <link rel="stylesheet" href="../../css/style.css">
  <!-- Mermaid for flowcharts -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.0/dist/mermaid.min.js"></script>
  <!-- Prism for code highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
</head>
<body>
  <button class="menu-toggle">â˜°</button>
  
  <aside class="sidebar">
    <div class="sidebar-header">
      <h1>TuPhung Project</h1>
    </div>
    
    <nav class="sidebar-nav">
      <div class="sidebar-section">
        <div class="sidebar-section-title">Overview</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../../index.html" class="sidebar-subnav-link">Introduction</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../architecture.html" class="sidebar-subnav-link">Architecture</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../tech-stack.html" class="sidebar-subnav-link">Tech Stack</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Frontend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="auth.html" class="sidebar-subnav-link">Authentication</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="chat.html" class="sidebar-subnav-link">Chat System</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="kanban.html" class="sidebar-subnav-link">Kanban Board</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="calendar.html" class="sidebar-subnav-link active">Calendar</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="ai-assistants.html" class="sidebar-subnav-link">AI Assistants</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="language-ai.html" class="sidebar-subnav-link">Language AI</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="state-management.html" class="sidebar-subnav-link">State Management</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Backend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../backend/structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/auth.html" class="sidebar-subnav-link">Authentication & Security</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/database.html" class="sidebar-subnav-link">Database Design</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/api.html" class="sidebar-subnav-link">API Endpoints</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/websockets.html" class="sidebar-subnav-link">WebSockets</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/speech-processing.html" class="sidebar-subnav-link">Speech Processing</a>
          </li>
        </ul>
      </div>
    </nav>
  </aside>
  
  <main class="main-content">
    <header class="content-header">
      <h1>Calendar</h1>
      <p>Comprehensive documentation of the Calendar feature in the TuPhung Project.</p>
    </header>
    
    <section>
      <h2>Overview</h2>
      <p>
        The Calendar feature in the TuPhung Project provides a comprehensive event management system that allows users 
        to schedule, view, and manage events. It supports different calendar views, recurring events, reminders, 
        and integration with other project features.
      </p>
      
      <div class="component-card">
        <h3>Key Features</h3>
        <ul>
          <li><strong>Multiple Views</strong> - Month, week, day, and agenda views</li>
          <li><strong>Event Creation</strong> - Create events with title, description, location, and participants</li>
          <li><strong>Recurring Events</strong> - Set up events that repeat on a schedule</li>
          <li><strong>Event Categories</strong> - Categorize events with color coding</li>
          <li><strong>Reminders</strong> - Set reminders for upcoming events</li>
          <li><strong>Drag and Drop</strong> - Easily reschedule events by dragging</li>
          <li><strong>Event Sharing</strong> - Share events with other users</li>
          <li><strong>Calendar Sync</strong> - Sync with external calendars</li>
          <li><strong>Search</strong> - Search for events by title, description, or participants</li>
        </ul>
      </div>
      
      <h2>Architecture</h2>
      
      <div class="diagram-container">
        <div class="diagram-title">Calendar Architecture</div>
        <div class="mermaid">
          graph TD
            User[User] --> UI[Calendar UI]
            UI --> CalendarView[Calendar View]
            UI --> EventForm[Event Form]
            UI --> EventDetails[Event Details]
            
            CalendarView --> CalendarState[Calendar State]
            EventForm --> CalendarState
            EventDetails --> CalendarState
            
            CalendarState --> CalendarService[Calendar Service]
            CalendarService --> API[REST API]
            
            API --> Backend[Backend Server]
            Backend --> Database[(Database)]
            
            subgraph Frontend
              UI
              CalendarView
              EventForm
              EventDetails
              CalendarState
              CalendarService
            end
            
            subgraph Backend
              API
              Backend
              Database
            end
        </div>
      </div>
      
      <h2>Frontend Implementation</h2>
      
      <p>
        The Calendar frontend is built using React with TypeScript and leverages the react-big-calendar library 
        for the calendar display. The state management is handled through Redux, with a dedicated slice for 
        calendar-related state.
      </p>
      
      <div class="component-card">
        <h3>Main Components</h3>
        <p>The Calendar feature consists of several key components:</p>
        
        <h4>1. CalendarPage Component</h4>
        <p>
          This is the main container component that renders the entire calendar interface. It manages the calendar 
          state, handles view changes, and coordinates the display of events.
        </p>
        
        <p>Key responsibilities:</p>
        <ul>
          <li>Loading events from the backend</li>
          <li>Managing calendar view (month, week, day)</li>
          <li>Handling date navigation</li>
          <li>Opening event creation and editing forms</li>
        </ul>
        
        <p>Example implementation:</p>
        <pre><code class="language-typescript">// CalendarPage.tsx
import React, { useState, useEffect } from 'react';
import { Calendar, momentLocalizer, Views } from 'react-big-calendar';
import moment from 'moment';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Select, Modal } from 'antd';
import { PlusOutlined } from '@ant-design/icons';
import { fetchEvents, createEvent, updateEvent, deleteEvent } from '../services/calendarService';
import { setEvents, addEvent, updateEvent as updateEventAction, removeEvent } from '../store/calendarSlice';
import { RootState } from '../store/rootState';
import EventForm from '../components/EventForm';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import '../styles/Calendar.css';

const localizer = momentLocalizer(moment);

const CalendarPage: React.FC = () => {
  const dispatch = useDispatch();
  const { events } = useSelector((state: RootState) => state.calendar);
  const [view, setView] = useState(Views.MONTH);
  const [date, setDate] = useState(new Date());
  const [isModalVisible, setIsModalVisible] = useState(false);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [isCreating, setIsCreating] = useState(false);
  
  useEffect(() => {
    const loadEvents = async () => {
      try {
        const eventData = await fetchEvents();
        dispatch(setEvents(eventData));
      } catch (error) {
        console.error('Failed to load events:', error);
      }
    };
    
    loadEvents();
  }, [dispatch]);
  
  const handleViewChange = (newView) => {
    setView(newView);
  };
  
  const handleNavigate = (newDate) => {
    setDate(newDate);
  };
  
  const handleSelectSlot = ({ start, end }) => {
    setSelectedEvent(null);
    setIsCreating(true);
    setIsModalVisible(true);
  };
  
  const handleSelectEvent = (event) => {
    setSelectedEvent(event);
    setIsCreating(false);
    setIsModalVisible(true);
  };
  
  const handleCreateEvent = async (eventData) => {
    try {
      const newEvent = await createEvent(eventData);
      dispatch(addEvent(newEvent));
      setIsModalVisible(false);
    } catch (error) {
      console.error('Failed to create event:', error);
    }
  };
  
  const handleUpdateEvent = async (eventData) => {
    try {
      const updatedEvent = await updateEvent(eventData);
      dispatch(updateEventAction(updatedEvent));
      setIsModalVisible(false);
    } catch (error) {
      console.error('Failed to update event:', error);
    }
  };
  
  const handleDeleteEvent = async (eventId) => {
    try {
      await deleteEvent(eventId);
      dispatch(removeEvent(eventId));
      setIsModalVisible(false);
    } catch (error) {
      console.error('Failed to delete event:', error);
    }
  };
  
  return (
    &lt;div className="calendar-container"&gt;
      &lt;div className="calendar-header"&gt;
        &lt;h1&gt;Calendar&lt;/h1&gt;
        &lt;div className="calendar-controls"&gt;
          &lt;Select 
            value={view} 
            onChange={handleViewChange}
            options={[
              { value: Views.MONTH, label: 'Month' },
              { value: Views.WEEK, label: 'Week' },
              { value: Views.DAY, label: 'Day' },
              { value: Views.AGENDA, label: 'Agenda' }
            ]}
          /&gt;
          &lt;Button 
            type="primary" 
            icon={&lt;PlusOutlined /&gt;} 
            onClick={() => {
              setSelectedEvent(null);
              setIsCreating(true);
              setIsModalVisible(true);
            }}
          &gt;
            New Event
          &lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      
      &lt;Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: 'calc(100vh - 120px)' }}
        view={view}
        date={date}
        onView={handleViewChange}
        onNavigate={handleNavigate}
        onSelectSlot={handleSelectSlot}
        onSelectEvent={handleSelectEvent}
        selectable
        popup
      /&gt;
      
      &lt;Modal
        title={isCreating ? "Create Event" : "Edit Event"}
        open={isModalVisible}
        onCancel={() => setIsModalVisible(false)}
        footer={null}
        width={600}
      &gt;
        &lt;EventForm
          event={selectedEvent}
          isCreating={isCreating}
          onSubmit={isCreating ? handleCreateEvent : handleUpdateEvent}
          onDelete={handleDeleteEvent}
        /&gt;
      &lt;/Modal&gt;
    &lt;/div&gt;
  );
};</code></pre>
        
        <h4>2. EventForm Component</h4>
        <p>
          This component provides a form for creating and editing events. It includes fields for event title, 
          description, date and time, location, and other event properties.
        </p>
        
        <p>Key features:</p>
        <ul>
          <li>Form validation</li>
          <li>Date and time selection</li>
          <li>Recurring event options</li>
          <li>Category selection</li>
          <li>Participant management</li>
        </ul>
        
        <p>Example implementation:</p>
        <pre><code class="language-typescript">// EventForm.tsx
import React, { useState, useEffect } from 'react';
import { Form, Input, Button, DatePicker, Checkbox, Select, TimePicker, Space } from 'antd';
import { DeleteOutlined } from '@ant-design/icons';
import moment from 'moment';
import { EventCategory, RecurrencePattern } from '../types/calendar';

const { RangePicker } = DatePicker;
const { TextArea } = Input;
const { Option } = Select;

interface EventFormProps {
  event?: any;
  isCreating: boolean;
  onSubmit: (eventData: any) => void;
  onDelete?: (eventId: string) => void;
}

const EventForm: React.FC&lt;EventFormProps&gt; = ({ event, isCreating, onSubmit, onDelete }) => {
  const [form] = Form.useForm();
  const [isRecurring, setIsRecurring] = useState(false);
  
  useEffect(() => {
    if (event) {
      form.setFieldsValue({
        title: event.title,
        description: event.description,
        dateRange: [moment(event.start), moment(event.end)],
        allDay: event.allDay,
        location: event.location,
        category: event.category,
        recurrence: event.recurrence?.pattern,
        participants: event.participants
      });
      setIsRecurring(!!event.recurrence);
    } else {
      form.resetFields();
      setIsRecurring(false);
    }
  }, [event, form]);
  
  const handleSubmit = (values) => {
    const { dateRange, ...rest } = values;
    
    const eventData = {
      ...rest,
      start: dateRange[0].toDate(),
      end: dateRange[1].toDate(),
      id: event?.id
    };
    
    if (isRecurring && values.recurrence) {
      eventData.recurrence = {
        pattern: values.recurrence,
        endDate: values.recurrenceEndDate?.toDate()
      };
    }
    
    onSubmit(eventData);
  };
  
  const handleDelete = () => {
    if (onDelete && event?.id) {
      onDelete(event.id);
    }
  };
  
  return (
    &lt;Form
      form={form}
      layout="vertical"
      onFinish={handleSubmit}
    &gt;
      &lt;Form.Item
        name="title"
        label="Event Title"
        rules={[{ required: true, message: 'Please enter event title' }]}
      &gt;
        &lt;Input placeholder="Enter event title" /&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item
        name="description"
        label="Description"
      &gt;
        &lt;TextArea rows={4} placeholder="Enter event description" /&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item
        name="dateRange"
        label="Event Date and Time"
        rules={[{ required: true, message: 'Please select event date and time' }]}
      &gt;
        &lt;RangePicker showTime format="YYYY-MM-DD HH:mm" style={{ width: '100%' }} /&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item
        name="allDay"
        valuePropName="checked"
      &gt;
        &lt;Checkbox&gt;All Day Event&lt;/Checkbox&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item
        name="location"
        label="Location"
      &gt;
        &lt;Input placeholder="Enter event location" /&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item
        name="category"
        label="Category"
      &gt;
        &lt;Select placeholder="Select a category"&gt;
          &lt;Option value={EventCategory.MEETING}&gt;Meeting&lt;/Option&gt;
          &lt;Option value={EventCategory.TASK}&gt;Task&lt;/Option&gt;
          &lt;Option value={EventCategory.REMINDER}&gt;Reminder&lt;/Option&gt;
          &lt;Option value={EventCategory.PERSONAL}&gt;Personal&lt;/Option&gt;
          &lt;Option value={EventCategory.OTHER}&gt;Other&lt;/Option&gt;
        &lt;/Select&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item&gt;
        &lt;Checkbox checked={isRecurring} onChange={(e) => setIsRecurring(e.target.checked)}&gt;
          Recurring Event
        &lt;/Checkbox&gt;
      &lt;/Form.Item&gt;
      
      {isRecurring && (
        &lt;Space direction="vertical" style={{ width: '100%' }}&gt;
          &lt;Form.Item
            name="recurrence"
            label="Recurrence Pattern"
          &gt;
            &lt;Select placeholder="Select recurrence pattern"&gt;
              &lt;Option value={RecurrencePattern.DAILY}&gt;Daily&lt;/Option&gt;
              &lt;Option value={RecurrencePattern.WEEKLY}&gt;Weekly&lt;/Option&gt;
              &lt;Option value={RecurrencePattern.BIWEEKLY}&gt;Bi-weekly&lt;/Option&gt;
              &lt;Option value={RecurrencePattern.MONTHLY}&gt;Monthly&lt;/Option&gt;
              &lt;Option value={RecurrencePattern.YEARLY}&gt;Yearly&lt;/Option&gt;
            &lt;/Select&gt;
          &lt;/Form.Item&gt;
          
          &lt;Form.Item
            name="recurrenceEndDate"
            label="End Recurrence"
          &gt;
            &lt;DatePicker placeholder="Select end date (optional)" /&gt;
          &lt;/Form.Item&gt;
        &lt;/Space&gt;
      )}
      
      &lt;Form.Item
        name="participants"
        label="Participants"
      &gt;
        &lt;Select mode="tags" placeholder="Add participants (email or username)"&gt;&lt;/Select&gt;
      &lt;/Form.Item&gt;
      
      &lt;Form.Item&gt;
        &lt;Space&gt;
          &lt;Button type="primary" htmlType="submit"&gt;
            {isCreating ? 'Create Event' : 'Update Event'}
          &lt;/Button&gt;
          
          {!isCreating && (
            &lt;Button danger icon={&lt;DeleteOutlined /&gt;} onClick={handleDelete}&gt;
              Delete Event
            &lt;/Button&gt;
          )}
          
          &lt;Button htmlType="button" onClick={() => form.resetFields()}&gt;
            Reset
          &lt;/Button&gt;
        &lt;/Space&gt;
      &lt;/Form.Item&gt;
    &lt;/Form&gt;
  );
};</code></pre>
      </div>
      
      <h2>State Management</h2>
      
      <p>
        The Calendar state is managed through a dedicated Redux slice. This slice maintains the state of 
        events and provides actions for manipulating this state.
      </p>
      
      <div class="component-card">
        <h3>Calendar State Slice</h3>
        <pre><code class="language-typescript">// calendarSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { CalendarEvent } from '../types/calendar';

interface CalendarState {
  events: CalendarEvent[];
  loading: boolean;
  error: string | null;
}

const initialState: CalendarState = {
  events: [],
  loading: false,
  error: null
};

const calendarSlice = createSlice({
  name: 'calendar',
  initialState,
  reducers: {
    setEvents: (state, action: PayloadAction&lt;CalendarEvent[]&gt;) => {
      state.events = action.payload;
    },
    addEvent: (state, action: PayloadAction&lt;CalendarEvent&gt;) => {
      state.events.push(action.payload);
    },
    updateEvent: (state, action: PayloadAction&lt;CalendarEvent&gt;) => {
      const index = state.events.findIndex(event => event.id === action.payload.id);
      if (index !== -1) {
        state.events[index] = action.payload;
      }
    },
    removeEvent: (state, action: PayloadAction&lt;string&gt;) => {
      state.events = state.events.filter(event => event.id !== action.payload);
    },
    setLoading: (state, action: PayloadAction&lt;boolean&gt;) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction&lt;string | null&gt;) => {
      state.error = action.payload;
    }
  }
});

export const {
  setEvents,
  addEvent,
  updateEvent,
  removeEvent,
  setLoading,
  setError
} = calendarSlice.actions;

export default calendarSlice.reducer;</code></pre>
      </div>
      
      <h2>Backend Integration</h2>
      
      <p>
        The Calendar frontend communicates with the backend through a set of API services. These services 
        handle operations such as fetching events, creating and updating events, and managing recurrence patterns.
      </p>
      
      <div class="component-card">
        <h3>Calendar API Service</h3>
        <pre><code class="language-typescript">// calendarService.ts
import axios from 'axios';
import { API_BASE_URL } from '../config';
import { CalendarEvent } from '../types/calendar';

const API_URL = `${API_BASE_URL}/calendar`;

export const fetchEvents = async (): Promise&lt;CalendarEvent[]&gt; => {
  const response = await axios.get(`${API_URL}/events`);
  return response.data.map(event => ({
    ...event,
    start: new Date(event.start),
    end: new Date(event.end),
    recurrence: event.recurrence ? {
      ...event.recurrence,
      endDate: event.recurrence.endDate ? new Date(event.recurrence.endDate) : null
    } : null
  }));
};

export const fetchEventById = async (eventId: string): Promise&lt;CalendarEvent&gt; => {
  const response = await axios.get(`${API_URL}/events/${eventId}`);
  const event = response.data;
  return {
    ...event,
    start: new Date(event.start),
    end: new Date(event.end),
    recurrence: event.recurrence ? {
      ...event.recurrence,
      endDate: event.recurrence.endDate ? new Date(event.recurrence.endDate) : null
    } : null
  };
};

export const createEvent = async (event: Omit&lt;CalendarEvent, 'id'&gt;): Promise&lt;CalendarEvent&gt; => {
  const response = await axios.post(`${API_URL}/events`, event);
  const newEvent = response.data;
  return {
    ...newEvent,
    start: new Date(newEvent.start),
    end: new Date(newEvent.end),
    recurrence: newEvent.recurrence ? {
      ...newEvent.recurrence,
      endDate: newEvent.recurrence.endDate ? new Date(newEvent.recurrence.endDate) : null
    } : null
  };
};

export const updateEvent = async (event: CalendarEvent): Promise&lt;CalendarEvent&gt; => {
  const response = await axios.put(`${API_URL}/events/${event.id}`, event);
  const updatedEvent = response.data;
  return {
    ...updatedEvent,
    start: new Date(updatedEvent.start),
    end: new Date(updatedEvent.end),
    recurrence: updatedEvent.recurrence ? {
      ...updatedEvent.recurrence,
      endDate: updatedEvent.recurrence.endDate ? new Date(updatedEvent.recurrence.endDate) : null
    } : null
  };
};

export const deleteEvent = async (eventId: string): Promise&lt;void&gt; => {
  await axios.delete(`${API_URL}/events/${eventId}`);
};

export const fetchEventsByDateRange = async (start: Date, end: Date): Promise&lt;CalendarEvent[]&gt; => {
  const response = await axios.get(`${API_URL}/events/range`, {
    params: {
      start: start.toISOString(),
      end: end.toISOString()
    }
  });
  return response.data.map(event => ({
    ...event,
    start: new Date(event.start),
    end: new Date(event.end),
    recurrence: event.recurrence ? {
      ...event.recurrence,
      endDate: event.recurrence.endDate ? new Date(event.recurrence.endDate) : null
    } : null
  }));
};</code></pre>
      </div>
      
      <h2>Styling</h2>
      
      <p>
        The Calendar is styled using a combination of the react-big-calendar default styles, Ant Design components, 
        and custom CSS. The styling focuses on providing a clean, intuitive interface that makes it easy to view 
        and manage events.
      </p>
      
      <div class="component-card">
        <h3>Key Styling Features</h3>
        <ul>
          <li>Responsive layout that adapts to different screen sizes</li>
          <li>Color coding for different event categories</li>
          <li>Clear visual distinction between all-day and timed events</li>
          <li>Consistent spacing and alignment</li>
          <li>Hover and selection states for interactive elements</li>
        </ul>
      </div>
    </section>
  </main>
  
  <script src="../../assets/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script>
    // Initialize syntax highlighting and mermaid diagrams
    document.addEventListener('DOMContentLoaded', (event) => {
      Prism.highlightAll();
      mermaid.initialize({ startOnLoad: true });
    });
  </script>
</body>
</html>