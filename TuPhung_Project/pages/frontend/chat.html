<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat System - TuPhung Project Documentation</title>
  <link rel="stylesheet" href="../../css/style.css">
  <!-- Mermaid for flowcharts -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.0/dist/mermaid.min.js"></script>
  <!-- Prism for code highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
</head>
<body>
  <button class="menu-toggle">â˜°</button>
  
  <aside class="sidebar">
    <div class="sidebar-header">
      <h1>TuPhung Project</h1>
    </div>
    
    <nav class="sidebar-nav">
      <div class="sidebar-section">
        <div class="sidebar-section-title">Overview</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../../index.html" class="sidebar-subnav-link">Introduction</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../architecture.html" class="sidebar-subnav-link">Architecture</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../tech-stack.html" class="sidebar-subnav-link">Tech Stack</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Frontend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="auth.html" class="sidebar-subnav-link">Authentication</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="chat.html" class="sidebar-subnav-link active">Chat System</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="kanban.html" class="sidebar-subnav-link">Kanban Board</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="calendar.html" class="sidebar-subnav-link">Calendar</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="ai-assistants.html" class="sidebar-subnav-link">AI Assistants</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="language-ai.html" class="sidebar-subnav-link">Language AI</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="state-management.html" class="sidebar-subnav-link">State Management</a>
          </li>
        </ul>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Backend</div>
        <ul class="sidebar-subnav">
          <li class="sidebar-subnav-item">
            <a href="../backend/structure.html" class="sidebar-subnav-link">Project Structure</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/auth.html" class="sidebar-subnav-link">Authentication & Security</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/user-management.html" class="sidebar-subnav-link">User Management</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/database.html" class="sidebar-subnav-link">Database Design</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/api.html" class="sidebar-subnav-link">API Endpoints</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/websockets.html" class="sidebar-subnav-link">WebSockets</a>
          </li>
          <li class="sidebar-subnav-item">
            <a href="../backend/speech-processing.html" class="sidebar-subnav-link">Speech Processing</a>
          </li>
        </ul>
      </div>
    </nav>
  </aside>
  
  <main class="main-content">
    <header class="content-header">
      <h1>Chat System</h1>
      <p>Comprehensive documentation of the Chat System in the TuPhung Project.</p>
    </header>
    
    <section>
      <h2>Overview</h2>
      <p>
        The Chat System in the TuPhung Project provides real-time messaging capabilities for users to communicate 
        with each other. It supports both one-on-one and group conversations, with features like message history, 
        typing indicators, read receipts, and file sharing.
      </p>
      
      <div class="component-card">
        <h3>Key Features</h3>
        <ul>
          <li><strong>Real-time Messaging</strong> - Instant message delivery using WebSockets</li>
          <li><strong>One-on-One Chats</strong> - Private conversations between two users</li>
          <li><strong>Group Chats</strong> - Conversations with multiple participants</li>
          <li><strong>Message History</strong> - Persistent storage and retrieval of past messages</li>
          <li><strong>Typing Indicators</strong> - Show when someone is typing a message</li>
          <li><strong>Read Receipts</strong> - Indicate when messages have been read</li>
          <li><strong>File Sharing</strong> - Send and receive files in conversations</li>
          <li><strong>Message Formatting</strong> - Support for rich text, emojis, and markdown</li>
          <li><strong>Message Search</strong> - Search through message history</li>
          <li><strong>Notifications</strong> - Alert users of new messages</li>
        </ul>
      </div>
      
      <h2>Architecture</h2>
      
      <div class="diagram-container">
        <div class="diagram-title">Chat System Architecture</div>
        <div class="mermaid">
          graph TD
            User[User] --> UI[Chat UI]
            UI --> ChatList[Chat Room List]
            UI --> MessageList[Message List]
            UI --> MessageInput[Message Input]
            
            ChatList --> ChatState[Chat State]
            MessageList --> ChatState
            MessageInput --> ChatState
            
            ChatState --> ChatService[Chat Service]
            ChatService --> WebSocket[WebSocket Connection]
            ChatService --> API[REST API]
            
            WebSocket --> Backend[Backend Server]
            API --> Backend
            Backend --> Database[(Database)]
            
            subgraph Frontend
              UI
              ChatList
              MessageList
              MessageInput
              ChatState
              ChatService
              WebSocket
            end
            
            subgraph Backend
              API
              Backend
              Database
            end
        </div>
      </div>
      
      <h2>Frontend Implementation</h2>
      
      <p>
        The Chat System frontend is built using React with TypeScript and leverages WebSockets for real-time 
        communication. The state management is handled through Redux, with a dedicated slice for chat-related state.
      </p>
      
      <div class="component-card">
        <h3>Main Components</h3>
        <p>The Chat System consists of several key components:</p>
        
        <h4>1. ChatPage Component</h4>
        <p>
          This is the main container component that renders the entire chat interface. It manages the chat state, 
          handles room selection, and coordinates the display of messages.
        </p>
        
        <p>Key responsibilities:</p>
        <ul>
          <li>Loading chat rooms and message history</li>
          <li>Managing WebSocket connection</li>
          <li>Handling room selection</li>
          <li>Coordinating message sending and receiving</li>
        </ul>
        
        <p>Example implementation:</p>
        <pre><code class="language-typescript">// ChatPage.tsx
import React, { useState, useEffect, useRef } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Layout, Button, Input, List, Avatar, Typography, Spin } from 'antd';
import { SendOutlined, UserOutlined, TeamOutlined, PlusOutlined } from '@ant-design/icons';
import { fetchChatRooms, fetchMessages, sendMessage } from '../services/chatService';
import { setChatRooms, setActiveRoom, addMessage, setMessages } from '../store/chatSlice';
import { RootState } from '../store/rootState';
import { ChatRoom, ChatMessage } from '../types/chat';
import { useWebSocket } from '../hooks/useWebSocket';
import CreateRoomModal from '../components/CreateRoomModal';
import '../styles/Chat.css';

const { Header, Sider, Content } = Layout;
const { TextArea } = Input;
const { Title, Text } = Typography;

const ChatPage: React.FC = () => {
  const dispatch = useDispatch();
  const { chatRooms, activeRoom, messages, loading } = useSelector(
    (state: RootState) => state.chat
  );
  const { user } = useSelector((state: RootState) => state.user);
  
  const [messageText, setMessageText] = useState('');
  const [isModalVisible, setIsModalVisible] = useState(false);
  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);
  
  // Initialize WebSocket connection
  const { sendSocketMessage, lastMessage } = useWebSocket(
    `${process.env.REACT_APP_WS_URL}/chat`,
    {
      onOpen: () => console.log('WebSocket connected'),
      onClose: () => console.log('WebSocket disconnected'),
      onError: (error) => console.error('WebSocket error:', error)
    }
  );
  
  // Load chat rooms on component mount
  useEffect(() => {
    const loadChatRooms = async () => {
      try {
        const rooms = await fetchChatRooms();
        dispatch(setChatRooms(rooms));
        
        if (rooms.length > 0 && !activeRoom) {
          dispatch(setActiveRoom(rooms[0]));
        }
      } catch (error) {
        console.error('Failed to load chat rooms:', error);
      }
    };
    
    loadChatRooms();
  }, [dispatch, activeRoom]);
  
  // Load messages when active room changes
  useEffect(() => {
    if (activeRoom) {
      const loadMessages = async () => {
        try {
          const messageHistory = await fetchMessages(activeRoom.id);
          dispatch(setMessages(messageHistory));
          scrollToBottom();
        } catch (error) {
          console.error('Failed to load messages:', error);
        }
      };
      
      loadMessages();
    }
  }, [activeRoom, dispatch]);
  
  // Handle incoming WebSocket messages
  useEffect(() => {
    if (lastMessage) {
      try {
        const data = JSON.parse(lastMessage.data);
        
        if (data.type === 'message' && data.roomId === activeRoom?.id) {
          dispatch(addMessage(data.message));
          scrollToBottom();
        } else if (data.type === 'typing') {
          // Handle typing indicator
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    }
  }, [lastMessage, activeRoom, dispatch]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    scrollToBottom();
  }, [messages]);
  
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  
  const handleRoomSelect = (room: ChatRoom) => {
    dispatch(setActiveRoom(room));
  };
  
  const handleSendMessage = async () => {
    if (!messageText.trim() || !activeRoom || !user) return;
    
    const newMessage: Omit&lt;ChatMessage, 'id' | 'timestamp'&gt; = {
      content: messageText,
      senderId: user.id,
      roomId: activeRoom.id,
      type: 'text'
    };
    
    setMessageText('');
    
    try {
      // Send message to backend
      const sentMessage = await sendMessage(newMessage);
      
      // Send message via WebSocket to notify other users
      sendSocketMessage(JSON.stringify({
        type: 'message',
        roomId: activeRoom.id,
        message: sentMessage
      }));
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  };
  
  const handleCreateRoom = () => {
    setIsModalVisible(true);
  };
  
  return (
    &lt;Layout className="chat-layout"&gt;
      &lt;Sider width={300} className="chat-sider"&gt;
        &lt;div className="chat-rooms-header"&gt;
          &lt;Title level={4}&gt;Chat Rooms&lt;/Title&gt;
          &lt;Button 
            type="primary" 
            icon={&lt;PlusOutlined /&gt;} 
            onClick={handleCreateRoom}
          &gt;
            New Chat
          &lt;/Button&gt;
        &lt;/div&gt;
        
        &lt;List
          className="chat-rooms-list"
          loading={loading}
          dataSource={chatRooms}
          renderItem={room => (
            &lt;List.Item
              className={`chat-room-item ${activeRoom?.id === room.id ? 'active' : ''}`}
              onClick={() => handleRoomSelect(room)}
            &gt;
              &lt;List.Item.Meta
                avatar={
                  &lt;Avatar icon={room.isGroup ? &lt;TeamOutlined /&gt; : &lt;UserOutlined /&gt;} /&gt;
                }
                title={room.name}
                description={room.lastMessage ? `${room.lastMessage.sender}: ${room.lastMessage.content}` : 'No messages yet'}
              /&gt;
              {room.unreadCount > 0 && (
                &lt;div className="unread-badge"&gt;{room.unreadCount}&lt;/div&gt;
              )}
            &lt;/List.Item&gt;
          )}
        /&gt;
      &lt;/Sider&gt;
      
      &lt;Layout className="chat-content-layout"&gt;
        {activeRoom ? (
          &lt;React.Fragment&gt;
            &lt;Header className="chat-header"&gt;
              &lt;div className="chat-header-info"&gt;
                &lt;Avatar 
                  size="large" 
                  icon={activeRoom.isGroup ? &lt;TeamOutlined /&gt; : &lt;UserOutlined /&gt;} 
                /&gt;
                &lt;div className="chat-header-text"&gt;
                  &lt;Title level={4}&gt;{activeRoom.name}&lt;/Title&gt;
                  &lt;Text type="secondary"&gt;
                    {activeRoom.isGroup 
                      ? `${activeRoom.participants.length} participants` 
                      : activeRoom.participants.find(p => p.id !== user?.id)?.status || 'Offline'}
                  &lt;/Text&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/Header&gt;
            
            &lt;Content className="chat-messages-container"&gt;
              {loading ? (
                &lt;div className="loading-container"&gt;
                  &lt;Spin size="large" /&gt;
                &lt;/div&gt;
              ) : (
                &lt;div className="messages-list"&gt;
                  {messages.map(message => (
                    &lt;div 
                      key={message.id}
                      className={`message-item ${message.senderId === user?.id ? 'own-message' : 'other-message'}`}
                    &gt;
                      {message.senderId !== user?.id && (
                        &lt;Avatar 
                          size="small" 
                          icon={&lt;UserOutlined /&gt;} 
                          className="message-avatar" 
                        /&gt;
                      )}
                      &lt;div className="message-content"&gt;
                        {message.senderId !== user?.id && (
                          &lt;div className="message-sender"&gt;
                            {activeRoom.participants.find(p => p.id === message.senderId)?.name || 'Unknown'}
                          &lt;/div&gt;
                        )}
                        &lt;div className="message-bubble"&gt;
                          {message.content}
                        &lt;/div&gt;
                        &lt;div className="message-time"&gt;
                          {new Date(message.timestamp).toLocaleTimeString()}
                        &lt;/div&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  ))}
                  &lt;div ref={messagesEndRef} /&gt;
                &lt;/div&gt;
              )}
            &lt;/Content&gt;
            
            &lt;div className="chat-input-container"&gt;
              &lt;TextArea
                value={messageText}
                onChange={e => setMessageText(e.target.value)}
                onPressEnter={e => {
                  if (!e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                  }
                }}
                placeholder="Type a message..."
                autoSize={{ minRows: 1, maxRows: 4 }}
              /&gt;
              &lt;Button 
                type="primary" 
                icon={&lt;SendOutlined /&gt;} 
                onClick={handleSendMessage}
                disabled={!messageText.trim()}
              /&gt;
            &lt;/div&gt;
          &lt;/React.Fragment&gt;
        ) : (
          &lt;div className="no-chat-selected"&gt;
            &lt;Title level={3}&gt;Select a chat or start a new conversation&lt;/Title&gt;
            &lt;Button 
              type="primary" 
              icon={&lt;PlusOutlined /&gt;} 
              onClick={handleCreateRoom}
            &gt;
              New Chat
            &lt;/Button&gt;
          &lt;/div&gt;
        )}
      &lt;/Layout&gt;
      
      &lt;CreateRoomModal
        visible={isModalVisible}
        onClose={() => setIsModalVisible(false)}
      /&gt;
    &lt;/Layout&gt;
  );
};</code></pre>
        
        <h4>2. CreateRoomModal Component</h4>
        <p>
          This component provides a modal for creating new chat rooms, either one-on-one or group chats.
        </p>
        
        <p>Key features:</p>
        <ul>
          <li>Selection between one-on-one and group chat</li>
          <li>User selection for participants</li>
          <li>Room name input for group chats</li>
          <li>Form validation</li>
        </ul>
        
        <p>Example implementation:</p>
        <pre><code class="language-typescript">// CreateRoomModal.tsx
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Modal, Form, Input, Select, Radio, Button } from 'antd';
import { UserOutlined, TeamOutlined } from '@ant-design/icons';
import { fetchUsers } from '../services/userService';
import { createChatRoom } from '../services/chatService';
import { addChatRoom, setActiveRoom } from '../store/chatSlice';
import { RootState } from '../store/rootState';
import { User } from '../types/user';

const { Option } = Select;

interface CreateRoomModalProps {
  visible: boolean;
  onClose: () => void;
}

const CreateRoomModal: React.FC&lt;CreateRoomModalProps&gt; = ({ visible, onClose }) => {
  const dispatch = useDispatch();
  const { user: currentUser } = useSelector((state: RootState) => state.user);
  
  const [form] = Form.useForm();
  const [roomType, setRoomType] = useState('individual');
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    if (visible) {
      const loadUsers = async () => {
        try {
          const userList = await fetchUsers();
          // Filter out current user
          setUsers(userList.filter(u => u.id !== currentUser?.id));
        } catch (error) {
          console.error('Failed to load users:', error);
        }
      };
      
      loadUsers();
      form.resetFields();
    }
  }, [visible, currentUser, form]);
  
  const handleRoomTypeChange = (e) => {
    setRoomType(e.target.value);
    form.setFieldsValue({ participants: [] });
  };
  
  const handleSubmit = async (values) => {
    if (!currentUser) return;
    
    setLoading(true);
    
    try {
      const roomData = {
        name: roomType === 'group' ? values.name : '',
        isGroup: roomType === 'group',
        participants: [...values.participants, currentUser.id]
      };
      
      const newRoom = await createChatRoom(roomData);
      
      dispatch(addChatRoom(newRoom));
      dispatch(setActiveRoom(newRoom));
      
      onClose();
    } catch (error) {
      console.error('Failed to create chat room:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    &lt;Modal
      title="Create New Chat"
      open={visible}
      onCancel={onClose}
      footer={null}
    &gt;
      &lt;Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
      &gt;
        &lt;Form.Item name="type" initialValue="individual"&gt;
          &lt;Radio.Group onChange={handleRoomTypeChange}&gt;
            &lt;Radio.Button value="individual"&gt;
              &lt;UserOutlined /&gt; One-on-One Chat
            &lt;/Radio.Button&gt;
            &lt;Radio.Button value="group"&gt;
              &lt;TeamOutlined /&gt; Group Chat
            &lt;/Radio.Button&gt;
          &lt;/Radio.Group&gt;
        &lt;/Form.Item&gt;
        
        {roomType === 'group' && (
          &lt;Form.Item
            name="name"
            label="Group Name"
            rules={[{ required: true, message: 'Please enter a group name' }]}
          &gt;
            &lt;Input placeholder="Enter group name" /&gt;
          &lt;/Form.Item&gt;
        )}
        
        &lt;Form.Item
          name="participants"
          label={roomType === 'group' ? 'Participants' : 'Select User'}
          rules={[{ 
            required: true, 
            message: roomType === 'group' 
              ? 'Please select at least one participant' 
              : 'Please select a user' 
          }]}
        &gt;
          &lt;Select
            mode={roomType === 'group' ? 'multiple' : undefined}
            placeholder={roomType === 'group' ? 'Select participants' : 'Select user'}
            showSearch
            filterOption={(input, option) =>
              option?.children.toLowerCase().indexOf(input.toLowerCase()) >= 0
            }
          &gt;
            {users.map(user => (
              &lt;Option key={user.id} value={user.id}&gt;{user.username}&lt;/Option&gt;
            ))}
          &lt;/Select&gt;
        &lt;/Form.Item&gt;
        
        &lt;Form.Item&gt;
          &lt;Button type="primary" htmlType="submit" loading={loading} block&gt;
            Create Chat
          &lt;/Button&gt;
        &lt;/Form.Item&gt;
      &lt;/Form&gt;
    &lt;/Modal&gt;
  );
};</code></pre>
      </div>
      
      <h2>State Management</h2>
      
      <p>
        The Chat System state is managed through a dedicated Redux slice. This slice maintains the state of 
        chat rooms, messages, and the active room, and provides actions for manipulating this state.
      </p>
      
      <div class="component-card">
        <h3>Chat State Slice</h3>
        <pre><code class="language-typescript">// chatSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { ChatRoom, ChatMessage } from '../types/chat';

interface ChatState {
  chatRooms: ChatRoom[];
  activeRoom: ChatRoom | null;
  messages: ChatMessage[];
  loading: boolean;
  error: string | null;
}

const initialState: ChatState = {
  chatRooms: [],
  activeRoom: null,
  messages: [],
  loading: false,
  error: null
};

const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    setChatRooms: (state, action: PayloadAction&lt;ChatRoom[]&gt;) => {
      state.chatRooms = action.payload;
    },
    addChatRoom: (state, action: PayloadAction&lt;ChatRoom&gt;) => {
      state.chatRooms.push(action.payload);
    },
    updateChatRoom: (state, action: PayloadAction&lt;ChatRoom&gt;) => {
      const index = state.chatRooms.findIndex(room => room.id === action.payload.id);
      if (index !== -1) {
        state.chatRooms[index] = action.payload;
      }
    },
    setActiveRoom: (state, action: PayloadAction&lt;ChatRoom&gt;) => {
      state.activeRoom = action.payload;
      
      // Reset unread count for the active room
      const roomIndex = state.chatRooms.findIndex(room => room.id === action.payload.id);
      if (roomIndex !== -1) {
        state.chatRooms[roomIndex].unreadCount = 0;
      }
    },
    setMessages: (state, action: PayloadAction&lt;ChatMessage[]&gt;) => {
      state.messages = action.payload;
    },
    addMessage: (state, action: PayloadAction&lt;ChatMessage&gt;) => {
      state.messages.push(action.payload);
      
      // Update last message in chat room
      const roomIndex = state.chatRooms.findIndex(room => room.id === action.payload.roomId);
      if (roomIndex !== -1) {
        state.chatRooms[roomIndex].lastMessage = {
          content: action.payload.content,
          sender: action.payload.senderName || 'Unknown',
          timestamp: action.payload.timestamp
        };
        
        // Increment unread count if not the active room
        if (state.activeRoom?.id !== action.payload.roomId) {
          state.chatRooms[roomIndex].unreadCount += 1;
        }
      }
    },
    setLoading: (state, action: PayloadAction&lt;boolean&gt;) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction&lt;string | null&gt;) => {
      state.error = action.payload;
    }
  }
});

export const {
  setChatRooms,
  addChatRoom,
  updateChatRoom,
  setActiveRoom,
  setMessages,
  addMessage,
  setLoading,
  setError
} = chatSlice.actions;

export default chatSlice.reducer;</code></pre>
      </div>
      
      <h2>WebSocket Integration</h2>
      
      <p>
        The Chat System uses WebSockets for real-time communication. A custom hook is used to manage the 
        WebSocket connection and handle messages.
      </p>
      
      <div class="component-card">
        <h3>WebSocket Hook</h3>
        <pre><code class="language-typescript">// useWebSocket.ts
import { useEffect, useRef, useState, useCallback } from 'react';

interface WebSocketOptions {
  onOpen?: (event: WebSocketEventMap['open']) => void;
  onClose?: (event: WebSocketEventMap['close']) => void;
  onMessage?: (event: WebSocketEventMap['message']) => void;
  onError?: (event: WebSocketEventMap['error']) => void;
  reconnectInterval?: number;
  reconnectAttempts?: number;
}

export const useWebSocket = (url: string, options: WebSocketOptions = {}) => {
  const [lastMessage, setLastMessage] = useState&lt;WebSocketEventMap['message'] | null&gt;(null);
  const [readyState, setReadyState] = useState&lt;number&gt;(WebSocket.CONNECTING);
  const webSocketRef = useRef&lt;WebSocket | null&gt;(null);
  const reconnectCount = useRef&lt;number&gt;(0);
  const reconnectTimerRef = useRef&lt;number | null&gt;(null);
  
  const {
    onOpen,
    onClose,
    onMessage,
    onError,
    reconnectInterval = 5000,
    reconnectAttempts = 10
  } = options;
  
  const connect = useCallback(() => {
    if (webSocketRef.current?.readyState === WebSocket.OPEN) return;
    
    webSocketRef.current = new WebSocket(url);
    setReadyState(WebSocket.CONNECTING);
    
    webSocketRef.current.onopen = (event) => {
      setReadyState(WebSocket.OPEN);
      reconnectCount.current = 0;
      if (onOpen) onOpen(event);
    };
    
    webSocketRef.current.onclose = (event) => {
      setReadyState(WebSocket.CLOSED);
      if (onClose) onClose(event);
      
      // Attempt to reconnect
      if (reconnectCount.current < reconnectAttempts) {
        reconnectCount.current += 1;
        reconnectTimerRef.current = window.setTimeout(() => {
          connect();
        }, reconnectInterval);
      }
    };
    
    webSocketRef.current.onmessage = (event) => {
      setLastMessage(event);
      if (onMessage) onMessage(event);
    };
    
    webSocketRef.current.onerror = (event) => {
      if (onError) onError(event);
    };
  }, [url, onOpen, onClose, onMessage, onError, reconnectInterval, reconnectAttempts]);
  
  useEffect(() => {
    connect();
    
    return () => {
      if (reconnectTimerRef.current) {
        clearTimeout(reconnectTimerRef.current);
      }
      
      if (webSocketRef.current) {
        webSocketRef.current.close();
      }
    };
  }, [connect]);
  
  const sendSocketMessage = useCallback((data: string | ArrayBufferLike | Blob | ArrayBufferView) => {
    if (webSocketRef.current?.readyState === WebSocket.OPEN) {
      webSocketRef.current.send(data);
      return true;
    }
    return false;
  }, []);
  
  return {
    lastMessage,
    readyState,
    sendSocketMessage
  };
};</code></pre>
      </div>
      
      <h2>Backend Integration</h2>
      
      <p>
        The Chat System frontend communicates with the backend through a set of API services. These services 
        handle operations such as fetching chat rooms, loading message history, and sending messages.
      </p>
      
      <div class="component-card">
        <h3>Chat API Service</h3>
        <pre><code class="language-typescript">// chatService.ts
import axios from 'axios';
import { API_BASE_URL } from '../config';
import { ChatRoom, ChatMessage } from '../types/chat';

const API_URL = `${API_BASE_URL}/chat`;

export const fetchChatRooms = async (): Promise&lt;ChatRoom[]&gt; => {
  const response = await axios.get(`${API_URL}/rooms`);
  return response.data;
};

export const fetchMessages = async (roomId: string): Promise&lt;ChatMessage[]&gt; => {
  const response = await axios.get(`${API_URL}/rooms/${roomId}/messages`);
  return response.data;
};

export const sendMessage = async (message: Omit&lt;ChatMessage, 'id' | 'timestamp'&gt;): Promise&lt;ChatMessage&gt; => {
  const response = await axios.post(`${API_URL}/messages`, message);
  return response.data;
};

export const createChatRoom = async (roomData: {
  name: string;
  isGroup: boolean;
  participants: string[];
}): Promise&lt;ChatRoom&gt; => {
  const response = await axios.post(`${API_URL}/rooms`, roomData);
  return response.data;
};

export const updateChatRoom = async (roomId: string, roomData: {
  name?: string;
  participants?: string[];
}): Promise&lt;ChatRoom&gt; => {
  const response = await axios.put(`${API_URL}/rooms/${roomId}`, roomData);
  return response.data;
};

export const leaveChatRoom = async (roomId: string): Promise&lt;void&gt; => {
  await axios.post(`${API_URL}/rooms/${roomId}/leave`);
};

export const markMessagesAsRead = async (roomId: string): Promise&lt;void&gt; => {
  await axios.post(`${API_URL}/rooms/${roomId}/read`);
};</code></pre>
      </div>
      
      <h2>Styling</h2>
      
      <p>
        The Chat System is styled using a combination of Ant Design components and custom CSS. The styling 
        focuses on providing a clean, intuitive interface that makes it easy to read and send messages.
      </p>
      
      <div class="component-card">
        <h3>Key Styling Features</h3>
        <ul>
          <li>Responsive layout that adapts to different screen sizes</li>
          <li>Clear visual distinction between sent and received messages</li>
          <li>Unread message indicators</li>
          <li>Typing indicators</li>
          <li>Message timestamps</li>
          <li>Consistent spacing and alignment</li>
        </ul>
      </div>
    </section>
  </main>
  
  <script src="../../assets/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script>
    // Initialize syntax highlighting and mermaid diagrams
    document.addEventListener('DOMContentLoaded', (event) => {
      Prism.highlightAll();
      mermaid.initialize({ startOnLoad: true });
    });
  </script>
</body>
</html>